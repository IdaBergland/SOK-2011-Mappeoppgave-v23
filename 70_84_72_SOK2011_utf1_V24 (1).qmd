---
title: "Utfording 1"
subtitle: "Fakultet for biovitenskap, fiskeri og √∏konomi."
author: "Kandidatnummer 70, 84, 72, SOK-2011 V√•r 2024"
date: last-modified 
date-format: "DD-MM-YYYY"
editor: visual
abstract: | 
    | Oppgaven er skrevet i gruppe med kandidater 70, 84, 72
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
    | 
format: 
  pdf:
    geometry:
      - top=20mm
      - left=20mm
      - heightrounded
    fontsize: 12pt
    documentclass: scrartcl
    papersize: a4
    toc-title: "Innholdsfortegnelse"
    toc: true
    toccolor: black
echo: false
bibliography: references.bib
csl: norsk-apa-manual.csl
crossref: 
  lof-title: "Figurliste"
  fig-title: "Figur"
  lot-title: "Tabelliste"
  tbl-title: "Tabell"
header-includes:
  - \usepackage{wrapfig}
  - \usepackage{subcaption}
  - \usepackage{amsmath}
  - \usepackage{cancel}
nocite: |
  @*
keep-tex: true
---

```{=tex}
\listoffigures
\listoftables
\renewcommand*{\figureautorefname}{Figur}
\renewcommand*{\tableautorefname}{Tabell}
\newpage
```
```{r}
rm(list=ls())
```

# Utfordring 1.1

Solow-modellen predikerer at niv√•et p√• spareraten og befolkningsvekstraten, er helt sentrale for niv√•et p√• produksjonen per arbeider p√• lang sikt (steady state).

### Gj√∏r rede for antakelsene i den grunnleggende Solow-modellen (uten teknologisk utvikling) og uten naturressurser.

F√∏r man regner med Solow-modellen s√• m√• man ta
for seg en del antagelser som m√• ligge til grunn for √• best mulig og enklest
gj√∏re det sammenlignbart. Og i forhold til den grunnleggende Solow-modellen s√• g√•r man ut fra
disse antakelsene:

1.  Alle bedrifter produserer et homogent gode.

2.  Fulkommen konkurranse, som vil si at bedriftene har en profitt p√• kroner 0.

3.  En har to produksjonsfaktorer, arbeid og kapital, definert ved $Prod(Y)=Kapital(k) \> og \> arbeid(L)$

4.  Konstant skalautbytte og avtakende marginal produktivitet, som vil si at ved konstant skalautbytte s√• vil for eksempel en dobling i innsatsfaktor(ene) gi en dobling i produksjonen, men siden den ogs√• er avtagende i marginalproduktiviteten s√• vil √∏kningen i produskjonen v√¶re avtagende for hver √∏kning

5.  Alle i befolkningen (p) er i arbeid. $L=p$, det tas ikke hensyn til de som ikke er i stand til √• jobbe, alle regnes under ett.

6.  Befolkningen vokser med en konstant, eksogent gitt rate (n): $L(t)=L_0 e^{nt}$

7.  Spareraten(netto) er eksogent gitt. og er lik for alle. og er en andel av den totale inntekten. $0\leq S\leq 1$

8.  Lukket √∏konomi. som vil si at Import = 0 = Eksport, alts√• ingen handel med utlandet.

#### Konsekvenser ved antagelsene.

1.  All produksjon blir inntekt. Som er et m√•l p√• konsummuligheten og som igjen er et m√•l p√• materiell velferd.

2.  Sparing = Investering. All sparing blir produktivt kapital. Positiv nettosparing f√∏rer til vekst i kapitalstokken.

\clearpage

### Utled steady-state-niv√•et p√• kapital og produksjon i den grunnleggende Solow-modellen matematisk.

```{python include =FALSE}
#%%capture
import sympy as sp 
import numpy as np
import matplotlib.pyplot as plt


alpha, t, s, k, n = sp.symbols('\u03B1 t s k n', real=True)


Y = sp.Function('Y')(t)  # Y(t)
K = sp.Function('K')(t)  # K(t)
L = sp.Function('L')(t)  # L(t)
k = sp.Function('k')(t)  # k(t)
y = sp.Function('y')(t)  # y(t)



Yfunc = sp.Eq(Y, K**alpha * L**(1-alpha))
yfunc = Yfunc.subs(Y, y*L)
yfuncleft = yfunc.subs(K, k*L).lhs/ L
yfuncright = yfunc.subs(K, k*L).rhs/ L
yfunc = sp.Eq(yfuncleft, yfuncright)

#y(t) = k(t)**alpha

#yfunc = sp.Eq(y, k**alpha)

#S = Netto nyinvesteringer 
#n = befolkningsvekst. eksogent gitt og voksede med konstant rate n
#k(t) = K(t)/L(t)
#k derivert for t = s*y(t)
# L(t) vokser med en eksogent og konstant rate n. L(t)=L(0)*e^(n*t)


#natural log of yfunc
lnyfunc = sp.Eq(sp.log(y), sp.log(k**alpha))
#derivative of lnyfunc
dlnyfunc = sp.Eq(sp.diff(sp.log(y), t), sp.diff(sp.log(k**alpha), t))
#dlnyfunc
```

Vi definerer produksjonsfunksjonen hvor produksjonen avhenger av kapital og arbeid. $1 >\alpha > 0$ $$ Y(t) = K(t)^\alpha L(t)^{1-\alpha}$$ Y viser oss BNP der kapital og arbeidskraft er de eneste produksjonsfaktorene, men p√• grunn av avtakende grenseproduktivitet vist med $\alpha$ og $1-\alpha$ ,s√• vil en √∏kt mengde av enten kapital eller arbeidskraft bidra mindre enn 1:1 til totalproduksjonen.

```{=tex}
\fbox{
 \addtolength{\linewidth}{-2\fboxsep}%
 \addtolength{\linewidth}{-2\fboxrule}%
 \begin{minipage}{\linewidth}
  \begin{equation}
    Y(t) = K(t)^\alpha \cdot L(t)^{1-\alpha}
  \end{equation}
  \begin{equation}
    \frac{Y(t)}{L(t)} = \frac{K(t)^\alpha \cdot L(t)^{1-\alpha}}{L(t)}
  \end{equation}
  \begin{equation}
    y(t) = K(t)^\alpha \cdot L(t)^{1-\alpha}\cdot L(t)^{-1}
  \end{equation}
  \begin{equation}
    y(t) = K(t)^\alpha \cdot L(t)^{1-\alpha-1} => K(t)^\alpha \cdot L(t)^{-\alpha} => \left( \frac{K(t)}{L(t)} \right)^\alpha
  \end{equation}
  \begin{equation}
    y(t) = \left( \frac{K(t)}{L(t)} \right)^\alpha 
  \end{equation}
  \begin{equation}
    y(t) =  k(t)^\alpha
  \end{equation}
 \end{minipage}
}
```
$y(t) = k(t)^\alpha$ viser forholdet mellom kapital per arbeider og produksjon per arbeider. P√• denne m√•ten kan vi se at det som p√•virker BNP per kapita er avhengig av hvor mye kapital som er tilgjengelig per arbeider. For eksempel vil det gi oss en lav BNP, dersom det var 1 traktor for hver 10 arbeider, men dersom det var 1 traktor for hver arbeider s√• vil BNP per kapita v√¶re h√∏yere, men samtidig kan vi se at dersom hver arbeider da hadde 2 traktorer s√• ville det ikke bidratt like mye til BNP per kapita som det den f√∏rste traktoren gjorde.

Ved √• ta logaritmen av begge sider av likning (6) f√•r vi

$$\ln y(t) = \alpha \cdot \ln k(t)$$

s√• kan vi derivere begge sider med hensyn p√• t

$$\frac{\frac{\partial}{\partial t} y{\left(t \right)}}{y{\left(t \right)}} = \frac{Œ± \frac{\partial}{\partial t} k{\left(t \right)}}{k{\left(t \right)}}$$

Dette skriver vi s√• om til

$$\frac{1}{y(t)} \cdot \frac{\partial y(t)}{\partial t} = \alpha \cdot \frac{1}{k(t)} \cdot \frac{\partial k(t)}{\partial t}$$

Vi blir √• skrive $\frac{1}{y(t)} \cdot \frac{\partial y(t)}{\partial t}$ som $g_y(t)$ og $\frac{1}{k(t)} \cdot \frac{\partial k(t)}{\partial t}$ som $g_k(t)$

$$g_y = \alpha \cdot g_k$$

For √• finne vekst i kapital per arbeider, s√• m√• vi se p√• hva vi vet om $k(t)$. Antagelse 6 er gitt i ligning 9.

```{=tex}
\fbox{
 \addtolength{\linewidth}{-2\fboxsep}%
 \addtolength{\linewidth}{-2\fboxrule}%
 \begin{minipage}{\linewidth}
  \begin{equation}
    k(t) = \frac{K(t)}{L(t)}
  \end{equation}
  \begin{equation}
    \frac{\partial k(t)}{\partial t} = s \cdot y(t)
  \end{equation}
  \begin{equation}
    L(t) = L_0 \cdot e^{n\cdot t} 
  \end{equation}
 \end{minipage}
}
```
Som vist i ligning 9 s√• vokser L med en eksogent gitt og konstant rate.

Tar logaritmen av ligning 7 $\ln(k(t)) = \ln(K((t)) - \ln(L(t))$ og deriverer.

$$\frac{1}{k(t)} \cdot \frac {\partial k(t)}{\partial t} = \frac{1}{K(t)}- \frac{1}{L(t)} \cdot \frac{\partial L(t)}{\partial t}$$ $\frac{1}{K(t)} = s \cdot Y(t)$ $\frac{\partial L(t)}{\partial t}$ = $n$

$$\frac{1}{k(t)} \cdot \frac {\partial k(t)}{\partial t} = \frac{s \cdot Y(t)}{K(t)}- n$$

Deler s√• for √• f√• det i per kapita

$\frac{1}{k(t)} \cdot \frac {\partial k(t)}{\partial t} = s \cdot \frac{\frac{Y(t)}{L(t)}}{\frac{K(t)}{L(t)}} -n$

$\frac{1}{k(t)} \cdot \frac {\partial k(t)}{\partial t} = s \cdot \frac{y(t)}{k(t)} - n$

$\frac{1}{k(t)} \cdot \frac {\partial k(t)}{\partial t} = s \cdot \frac{k^\alpha}{k} - n$

deler s√• inn p√• k

$\frac{\partial k}{\partial t} = s \cdot \frac{k^\alpha}{k}-n$

$$\frac{\partial k}{ \partial t} = s \cdot k^\alpha - n \cdot k \tag{10}$$

Vilk√•ret for steady state er da at ligning 10 er lik 0.

```{=tex}
\fbox{
 \addtolength{\linewidth}{-2\fboxsep}%
 \addtolength{\linewidth}{-2\fboxrule}%
 \begin{minipage}{\linewidth}
  \begin{equation}
    s \cdot k^{\alpha} - n \cdot k = 0
  \end{equation}
  \begin{equation}
    s \cdot k^{\alpha} = n \cdot k
  \end{equation}
  \begin{equation}
    \frac{s \cdot k^{\alpha}}{n} = k
  \end{equation}
  \begin{equation}
    \frac{s \cdot \cancel{k^{\alpha}}}{n} \cdot \frac{1}{\cancel{k^{\alpha}}} = k \cdot \frac{1}{k^{\alpha}}
  \end{equation}
  \begin{equation}
   \frac{s}{n} = k \cdot \frac{1}{k^\alpha}
  \end{equation}
  \begin{equation}
    \frac{s}{n} = k^{1-\alpha}
  \end{equation}
  \begin{equation}
    \left( \frac{s}{n}\right)^\frac{1}{1-\alpha} = \left(k^{\cancel{1-\alpha}}\right)^{\cancel{\frac{1}{1-\alpha}}}
  \end{equation}
  \begin{equation}
    k^{ss}=\left( \frac{s}{n}\right)^{\frac{1}{1-\alpha}}
  \end{equation}
 \end{minipage}
}
```
Siden $y(t)=k^\alpha$ s√• f√•r vi da $y^{ss}=\left(k^{ss}\right)^\alpha$

$y^{ss}=\left(\left( \frac{s}{n}\right)^\frac{1}{1-\alpha}\right)^\alpha$

ganger ut parantesene og f√•r

$$y^{ss}=\left( \frac{s}{n}\right)^\frac{\alpha}{1-\alpha}$$

som viser steady-state niv√•et for kapital per arbeider, som er punktet hvor √∏konomien ikke lenger opplever per kapita vekst i kapital eller produksjon. Dette forteller oss at for en gitt kombinasjon av sparerate og befolkningsvekstrate er det et niv√• av kapital per arbeider som √∏konomien vil konvergere mot over tid. √Ö ha 2 traktorer per arbeider vil v√¶re dyrt i drift og vil dermed lede til at det blir mindre kapital per kapita som demper produksjonen, det motsatte skjer n√•r det er langt f√¶rre traktorer enn det faktisk trengs, da alle som investerte penger i traktorer til arbeiderne, ville opplevd en stor avkastning og dermed ville alle investert opp til det konvergeringspunktet. En h√∏yere sparerate eller en lavere befolkningsvekst vil f√∏re til et h√∏yere steady-state niv√• av kapital per arbeider.

\clearpage

## Figurer:

```{python include=FALSE}

#%%capture

alpha_num = 0.5

eq = sp.Eq(s*k**alpha, n*k)

eq = sp.solve(eq, k)
intersect1 = eq[0].subs(alpha, alpha_num).subs(s, 0.4).subs(n, 0.1)
intersect2 = eq[0].subs(alpha, alpha_num).subs(s, 0.6).subs(n, 0.1)

intersect1 = float(intersect1)
intersect2 = float(intersect2)

def plotfunc(k, alpha):
    return k**alpha

def neeededinv(n, k):
    return n*k

def nettoinv(s, y):
    return s*y

x = np.linspace(0, 100, 1000)



fig, ax = plt.subplots(figsize=(7, 5))



#ax.plot(x, plotfunc(x, alpha_num), label='y(t)')

ax.plot(x, neeededinv(0.1, x), label='n*k(t)')

ax.plot(x, nettoinv(0.4, plotfunc(x, alpha_num)), label='s*y(t)')


for i in np.linspace(int(intersect1)-10, int(intersect1)-2, 5):
    ax.annotate('', xy=(i, neeededinv(0.1, i)), xytext=(i-0.5, neeededinv(0.1, i-0.5)),
                arrowprops=dict(facecolor='black', shrink=1, headwidth=8, headlength=8), annotation_clip=False)#denne blir ikke bedre. ikkje r√∏r. e AIDS


for i in np.linspace(int(intersect1)+2, int(intersect1)+10, 5):
    ax.annotate('', xy=(i, neeededinv(0.1, i)), xytext=(i+1, neeededinv(0.1, i+1)), 
                arrowprops=dict(facecolor='black', shrink=1, headwidth=8, headlength=8), annotation_clip=False)#denne blir ikke bedre. ikkje r√∏r. e AIDS





for i in np.linspace(int(intersect1)-10, int(intersect1)-2, 5):
    ax.annotate('', xy=(i, nettoinv(0.4, plotfunc(i, alpha_num))), xytext=(i-0.5, nettoinv(0.4, plotfunc(i-0.5, alpha_num))),
                arrowprops=dict(facecolor='black', shrink=1, headwidth=8, headlength=8), annotation_clip=False)#denne blir ikke bedre. ikkje r√∏r. e AIDS


for i in np.linspace(int(intersect1)+2, int(intersect1)+10, 5):
    ax.annotate('', xy=(i, nettoinv(0.4, plotfunc(i, alpha_num))), xytext=(i+0.5, nettoinv(0.4, plotfunc(i+0.5, alpha_num))), 
                arrowprops=dict(facecolor='black', shrink=1, headwidth=8, headlength=8), annotation_clip=False)#denne blir ikke bedre. ikkje r√∏r. e AIDS






#showing kss on k axis
ax.text(intersect1-1, -0.2, r'$k_0^{ss}$', fontsize=15)
ax.vlines(intersect1, 0, nettoinv(0.4, plotfunc(intersect1, alpha_num)), linestyle='dashed')


ax.text(23, 1.7, r'$s \cdot y$', fontsize=15)
ax.text(23, 2.8, r'$n \cdot k$', fontsize=15)

ax.text(-2, 0.4*plotfunc(intersect1, alpha_num), r'$y_0^{ss}$', fontsize=15)
ax.hlines(0.4*plotfunc(intersect1, alpha_num), 0, intersect1, linestyle='dashed')


#ax.scatter(intersect1, 0.4*plotfunc(intersect1, alpha_num), color='black', s=100)



ax.set_xlim(0, 30)
ax.set_ylim(0, 3)

#spines
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')


ax.set_xticks([])
ax.set_yticks([])

#ax.set_title('Likevekt i grunnleggende Solow-modell')
plt.savefig('Likevekt_grunnleggende.png', dpi=300, bbox_inches='tight')

```

```{=tex}
\begin{wrapfigure}{r}{0.5\textwidth}
    \includegraphics[width=0.48\textwidth]{Likevekt_grunnleggende.png}
  \caption{Likevekt i den grunnleggende Solow-modellen}
  \label{fig:likevekt_grunnleggende}
  \vspace{-12mm}
\end{wrapfigure}
```
```{python include=FALSE}

#%%capture

intersect1 = eq[0].subs(alpha, alpha_num).subs(s, 0.4).subs(n, 0.1)
intersect2 = eq[0].subs(alpha, alpha_num).subs(s, 0.6).subs(n, 0.1)



fig, (ax, ax1) = plt.subplots(1, 2, figsize=(15, 5))


ax.plot(x, neeededinv(0.1, x), label='n*k(t)')

ax.plot(x, nettoinv(0.4, plotfunc(x, alpha_num)), label='s0*y(t)')


for i in range(20, 40, 5):
    ax.annotate("", xy=(i, nettoinv(0.6, plotfunc(i, alpha_num))), xytext=(i, nettoinv(0.4, plotfunc(i, alpha_num))),
            arrowprops=dict(arrowstyle="->"))


ax.annotate("", xy=(5, nettoinv(0.6, plotfunc(5, alpha_num))), xytext=(5, nettoinv(0.4, plotfunc(5, alpha_num))),
            arrowprops=dict(arrowstyle="->"))

ax.plot(x, nettoinv(0.6, plotfunc(x, alpha_num)), label='s1 > s0')

ax.scatter(intersect1, 0.4*plotfunc(intersect1, alpha_num), label='k0ss')
ax.scatter(intersect2, 0.6*plotfunc(intersect2, alpha_num), label='k1ss')

for i in np.linspace(float(intersect1)+2, float(intersect2)-1, 5):
    ax.annotate('', xy=(i, neeededinv(0.1, i)), xytext=(i-1, neeededinv(0.1, i-1)),
                arrowprops=dict(facecolor='black', shrink=0.5, headwidth=5, headlength=5))#denne blir ikke bedre. ikkje r√∏r. e AIDS








ax.text(47, 3, r'$s_0 \cdot y$', fontsize=15)

ax.text(47, 3.8, r'$s_1 \cdot y$', fontsize=15)


ax.text(40, 4.5, r'$n \cdot k$', fontsize=15)


#showing kss on k axis
ax.text(intersect1-1, -0.3, r'$k_0^{ss}$', fontsize=15)
ax.vlines(intersect1, 0, nettoinv(0.4, plotfunc(intersect1, alpha_num)), linestyle='dashed')

ax.text(intersect2-1, -0.3, r'$k_1^{ss}$', fontsize=15)
ax.vlines(intersect2, 0, nettoinv(0.6, plotfunc(intersect2, alpha_num)), linestyle='dashed')



#showing yss on y axis
ax.text(-4, 0.4*plotfunc(intersect1, alpha_num), r'$y_0^{ss}$', fontsize=15)
ax.hlines(0.4*plotfunc(intersect1, alpha_num), 0, intersect1, linestyle='dashed')

ax.text(-4, 0.6*plotfunc(intersect2, alpha_num), r'$y_1^{ss}$', fontsize=15)
ax.hlines(0.6*plotfunc(intersect2, alpha_num), 0, intersect2, linestyle='dashed')


#arrow from kss0 to kss1 on x axis
ax.annotate("", xy=(intersect1+2, -0.1), xytext=(intersect2-1, -0.1),
            arrowprops=dict(arrowstyle="<-"), size=25, annotation_clip=False)


#arrow from yss0 to yss1 on y axis
ax.annotate("", xy=(-2, 0.4*plotfunc(intersect1, alpha_num)+0.3), xytext=(-2, 0.6*plotfunc(intersect2, alpha_num)-0.1),
            arrowprops=dict(arrowstyle="<-"), size=20,annotation_clip=False)




#no x or y numbers
ax.set_xticks([])
ax.set_yticks([])


ax.set_xlim(0, 60)
ax.set_ylim(0, 5)

#spines
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')



intersect1 = eq[0].subs(alpha, alpha_num).subs(s, 0.4).subs(n, 0.1)
intersect2 = eq[0].subs(alpha, alpha_num).subs(s, 0.4).subs(n, 0.15)




ax1.plot(x, neeededinv(0.1, x), label='n*k(t)')

ax1.plot(x, nettoinv(0.4, plotfunc(x, alpha_num)), label='s0*y(t)')

ax1.plot(x, neeededinv(0.15, x), label='n1 > n0')


ax1.annotate("", xy=(20, neeededinv(0.15, 20)), xytext=(20, neeededinv(0.1, 20)),
    arrowprops=dict(arrowstyle="->"))



ax1.scatter(intersect1, 0.4*plotfunc(intersect1, alpha_num), label='y0ss')
ax1.scatter(intersect2, 0.4*plotfunc(intersect2, alpha_num), label='y1ss')

for i in np.linspace(float(intersect1-1), float(intersect2+2), 6):
    ax1.annotate('', xy=(i-0.6, nettoinv(0.4, plotfunc(i-0.6, alpha_num))), xytext=(i, nettoinv(0.4, plotfunc(i, alpha_num))), 
                arrowprops=dict(facecolor='black', shrink=0.5, headwidth=8, headlength=5))#




ax1.text(23, 1.7, r'$s \cdot y$', fontsize=15)
ax1.text(23, 2.6, r'$n_0 \cdot k$', fontsize=15)
ax1.text(16, 2.8, r'$n_1 \cdot k$', fontsize=15)






# #showing kss on k axis
ax1.text(intersect1-1, -0.2, r'$k_0^{ss}$', fontsize=15)
ax1.vlines(intersect1, 0, nettoinv(0.4, plotfunc(intersect1, alpha_num)), linestyle='dashed')

ax1.text(intersect2-1, -0.2, r'$k_1^{ss}$', fontsize=15)
ax1.vlines(intersect2, 0, nettoinv(0.4, plotfunc(intersect2, alpha_num)), linestyle='dashed')



#showing yss on y axis
ax1.text(-2, 0.4*plotfunc(intersect1, alpha_num), r'$y_0^{ss}$', fontsize=15)
ax1.hlines(0.4*plotfunc(intersect1, alpha_num), 0, intersect1, linestyle='dashed')

ax1.text(-2, 0.4*plotfunc(intersect2, alpha_num), r'$y_1^{ss}$', fontsize=15)
ax1.hlines(0.4*plotfunc(intersect2, alpha_num), 0, intersect2, linestyle='dashed')


#arrow from kss0 to kss1 on x axis
ax1.annotate("", xy=(intersect1-1.5, -0.1), xytext=(intersect2+0.5, -0.1),
            arrowprops=dict(arrowstyle="<-"), size=25, annotation_clip=False)


#arrow from yss0 to yss1 on y axis
ax1.annotate("", xy=(-1, 0.4*plotfunc(intersect1, alpha_num)-0.05), xytext=(-1, 0.4*plotfunc(intersect2, alpha_num)+0.15),
            arrowprops=dict(arrowstyle="<-"), size=20,annotation_clip=False)




#no x or y numbers
ax1.set_xticks([])
ax1.set_yticks([])


ax1.set_xlim(0, 25)
ax1.set_ylim(0, 3)

#spines
ax1.spines['top'].set_color('none')
ax1.spines['right'].set_color('none')

ax.set_title('Sparerate √∏ker', fontsize=15)
ax1.set_title('Befolkningsvekstrate √∏ker', fontsize=15)



ax.text(18, 4.5, r'$s_1 > s_0$', fontsize=15)
ax1.text(7, 2.7, r'$n_1 > n_0$', fontsize=15)
plt.savefig('Figur2og3.png', dpi=300, bbox_inches='tight')



```

\autoref{fig:likevekt_grunnleggende} viser langsiktig likevekt i den grunnleggende Solow-modellen. Vist med piler er hva som vil skje dersom y hadde v√¶rt p√• et annet punkt p√• s\cdot y linjen. De vil bevege seg mot steady state niv√•et og stabiliseres der. Det er punktet der hvor nettoinvesteringer er lik de n√∏dvendige investeringer, for √• holde kapital per arbeider konstant.

S√• en √∏kning i s vil gi h√∏yere k og y. $k^{ss}=\left( \frac{s}{n}\right)^{\frac{1}{1-\alpha}}$

$y^{ss}=\left( \frac{s}{n}\right)^\frac{\alpha}{1-\alpha}$

```{=tex}
\begin{figure}[b]
  \centering
  \includegraphics[width=\linewidth]{Figur2og3.png}
  \captionof{figure}{Spareranten endres og befolkningsvekstraten endres}
  \label{fig:fig4}
\end{figure}
```
\autoref{fig:fig4} viser hva som skjer n√•r spareraten eller befolkningsvekstraten √∏ker. √òkning i spareraten gir et h√∏yere niv√• av $k^{ss}$ siden mer av hvert √•rs produksjon blir spart og investert i stedet for konsumert. Dette resulterer i et h√∏yere $y^{ss}$. S√• en √∏kning i s vil gi h√∏yere k og y.

En √∏kning i befolkningsvekstraten reduserer $k^{ss}$ og $y^{ss}$ fordi den samme mengden investeringer n√• m√• fordeles over flere arbeidere. Hvis befolkningen vokser raskere, s√• trenges det mer kapital per arbeider, som gj√∏r at produksjon per arbeider g√•r ned.

\clearpage

# Utfordring 1.2 Konvergensteori

Man har samme antagelser som tidligere fra Solow sin grunnmodell og en har ikke med teknologi eller naturressurser.

Konvergens-teorien er en √∏konomisk teori fra Solow-modellen som predikerer at fattige land vil vokse raskere enn rike land. Dette betyr at forskjellene i BNP per innbygger vil avta over tid. Den enkleste konvergens-teorien kalles for betingelsesl√∏s konvergens.

## **Betingelsesl√∏s konvergens (**Lik sparerate og befolkningsvekst i alle land)

Betingelsesl√∏s konvergens predikeres at dersom to land har ulik niv√• p√• BNP per arbeider $y^{fattig} \neq y^{rik}$ men lik produksjons-funksjon, sparerate, befolknings-vekstrate og depresieringsrate i kapitalen og ingen av de har kommet til steady-state. Da vil det fattige landet vokse raskere enn det rike landet og niv√•et i BNP per arbeider p√• sikt vil konvergere i de to landene, s√• $y^{fattig} \rightarrow y^{rik}$.

```{python include = FALSE}
#%%capture

# Figur for betingelsesl√∏s konvergens
alpha_num = 0.6
eq = sp.Eq(s*k**alpha, n*k)

eq = sp.solve(eq, k)
intersect1 = eq[0].subs(alpha, alpha_num).subs(s, 0.45).subs(n, 0.1)
intersect2 = eq[0].subs(alpha, alpha_num).subs(s, 0.6).subs(n, 0.1)

intersect1 = float(intersect1)
intersect2 = float(intersect2)

def plotfunc(k, alpha):
    return k**alpha

def neeededinv(n, k):
    return n*k

def nettoinv(s, y):
    return s*y

x = np.linspace(0, 100, 1000)

fig, (ax,ax2) = plt.subplots(1,2, figsize=(15, 5))


ax.plot(x, plotfunc(x, alpha_num), label='y(t)')
ax.plot(x, neeededinv(0.1, x), label='n*k(t)')
ax.plot(x, nettoinv(0.45, plotfunc(x, alpha_num)), label='s*y(t)')

ax.text(10, -0.8, r'$k_0^{fattig}$', fontsize=15)
ax.text(-8, 3.5, r'$y_0^{fattig}$', fontsize=15)
ax.vlines(10, 0, 4, linestyle='dashed',color="cornflowerblue")
ax.hlines(4, 0, 10, linestyle='dashed', color="cornflowerblue")
ax.text(25, -0.8, r'$k_0^{rik}$', fontsize=15)
ax.text(-5, 7, r'$y_0^{rik}$', fontsize=15)
ax.vlines(25, 0, 7, linestyle='dashed', color="palevioletred")
ax.hlines(7, 0, 25, linestyle='dashed', color="palevioletred")

# Setting y-axis label and making it horizontal and upper left corner
ax.set_ylabel('y', loc='top', rotation=0, fontsize=15)
# Setting k-axis label
ax.set_xlabel('k', loc='right', fontsize=15)
# Writing the equation for y = k**alpha
ax.text(45, 9, r'$y = k^{\alpha}$', fontsize=15)
# Writing the equation for n*k
ax.text(53, 6, r'$n \cdot k$', fontsize=15)
# Writing the equation for s*y = s*k**alpha
ax.text(50, 4.3, r'$s \cdot y = s \cdot k^{\alpha}$', fontsize=15)

ax.set_xlim(0, 65)
ax.set_ylim(0, 10)

# Making an extra thick line
ax.vlines(10, 1, 1.8,color="blue")
# Arrow pointing to extra thick line from y-axis
ax.arrow(0, 1.4, 8, 0, head_width=0.3, head_length=1, color='cornflowerblue',clip_on=False)
# Text writing the derivative of dk{fattig}/dt >> 0
ax.text(-8, 1.3, r'$\frac{d k^{fattig}}{d t} >> 0$', fontsize=12, color='cornflowerblue')
# Making an extra thick line
ax.vlines(25, 2.5, 3.1,color="red")
# Arrow pointing from the right to the left
ax.arrow(35, 2.8, -8, 0, head_width=0.3, head_length=1, color='palevioletred',clip_on=False)
# Text writing the derivative of dk{rik}/dt > 0
ax.text(35, 2.8, r'$\frac{d k^{rik}}{d t} > 0$', fontsize=14, color='palevioletred')
#Removing spines
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')


ax.set_xticks([])
ax.set_yticks([])

# showing 3 arrows
for i in range(12, 22, 4):
    ax.arrow(i, 0, 0.5, 0, head_width=0.3, head_length=1.2, fc='black',clip_on=False)

# showing 2 arrows
for i in range(28, 34, 3):
    ax.arrow(i, 0, 0.5, 0, head_width=0.3, head_length=1.2, fc='black',clip_on=False)
    
    

ax2.plot(x, plotfunc(x, alpha_num), label='y(t)')
ax2.plot(x, neeededinv(0.1, x), label='n*k(t)')
ax2.plot(x, nettoinv(0.45, plotfunc(x, alpha_num)), label='s*y(t)')

ax2.text(10, -0.8, r'$k_0^{fattig}$', fontsize=15)
ax2.text(-8, 3.5, r'$y_0^{fattig}$', fontsize=15)
ax2.vlines(10, 0, 4, linestyle='dashed',color="cornflowerblue")
ax2.hlines(4, 0, 10, linestyle='dashed', color="cornflowerblue")
ax2.text(25, -0.8, r'$k_0^{rik}$', fontsize=15)
ax2.text(-5, 7, r'$y_0^{rik}$', fontsize=15)
ax2.vlines(25, 0, 7, linestyle='dashed', color="palevioletred")
ax2.hlines(7, 0, 25, linestyle='dashed', color="palevioletred")

# Setting y-axis label and making it horizontal and upper left corner
ax2.set_ylabel('y', loc='top', rotation=0, fontsize=15)
# Setting k-axis label
ax2.set_xlabel('k', loc='right', fontsize=15)
# Writing the equation for y = k**alpha
ax2.text(45, 9, r'$y = k^{\alpha}$', fontsize=15)
# Writing the equation for n*k
ax2.text(53, 6, r'$n \cdot k$', fontsize=15)
# Writing the equation for s*y = s*k**alpha
ax2.text(50, 4.3, r'$s \cdot y = s \cdot k^{\alpha}$', fontsize=15)

ax2.set_xlim(0, 65)
ax2.set_ylim(0, 10)

# Making an extra thick line
ax2.vlines(10, 1, 1.8,color="blue")
# Arrow pointing to extra thick line from y-axis
ax2.arrow(0, 1.4, 8, 0, head_width=0.3, head_length=1, color='cornflowerblue',clip_on=False)
# Text writing the derivative of dk{fattig}/dt >> 0
ax2.text(-8, 1.3, r'$\frac{d k^{fattig}}{d t} >> 0$', fontsize=12, color='cornflowerblue')
# Making an extra thick line
ax2.vlines(25, 2.5, 3.1,color="red")
# Arrow pointing from the right to the left
ax2.arrow(35, 2.8, -8, 0, head_width=0.3, head_length=1, color='palevioletred',clip_on=False)
# Text writing the derivative of dk{rik}/dt > 0
ax2.text(35, 2.8, r'$\frac{d k^{rik}}{d t} > 0$', fontsize=13, color='palevioletred')
#Removing spines
ax2.spines['top'].set_color('none')
ax2.spines['right'].set_color('none')


ax2.set_xticks([])
ax2.set_yticks([])

ax2.hlines(0.6*plotfunc(intersect1, alpha_num)+3.78, 0, intersect1, linestyle='dashed', color="black")
ax2.vlines(intersect1, 0, nettoinv(0.45, plotfunc(intersect1, alpha_num))+5.25, linestyle='dashed', color="black")
ax2.scatter(intersect1, 0.45*plotfunc(intersect1, alpha_num), color='black', s=100)
# Writing the equation for y^(rik)^ss = y^(fattig)^ss
ax2.text(-14.5, 9.2, r'$y^{rik}_{ss} = y^{fattig}_{ss}$', fontsize=15)
# Writing the equation for k^(rik)^ss = k^(fattig)^ss
ax2.text(37, -0.7, r'$k^{rik}_{ss} = k^{fattig}_{ss}$', fontsize=15)
# showing 3 arrows
for i in range(12, 22, 4):
    ax2.arrow(i, 0, 0.5, 0, head_width=0.3, head_length=1.2, fc='black',clip_on=False)

# showing 2 arrows
for i in range(28, 34, 3):
    ax2.arrow(i, 0, 0.5, 0, head_width=0.3, head_length=1.2, fc='black',clip_on=False)

plt.savefig("figurx.png", dpi=300,bbox_inches='tight')
```

I \autoref{fig:figurx} ser man hvordan det fattige landet vil konvergere raskere mot steady state fordi tangenten til den deriverte i $\frac{\partial k^{fattig}}{\partial t}$ har et st√∏rre stigningstall enn det rike landet $\frac{\partial k^{rik}}{\partial t}$ og de faktiske investeringene til begge landene er st√∏rre enn de n√∏dvendige. Men $k^{fattig}$ har enda st√∏rre sprik mellom faktisk og n√∏dvendige investeringer s√• kapitalintensiteten vil √∏ke raskere.

```{=tex}
\begin{figure}[h]
\centering
  \includegraphics[width=\linewidth]{figurx.png}
  \captionof{figure}{Konvergens i Solow-modellen}
  \label{fig:figurx}
\end{figure}
```
Dette vil gi det fattige landet en st√∏rre vekst og begge to vil til slutt ende med produksjon per arbeider $y^{fattig}_{ss} = y^{rik}_{ss}$ og kapital per arbeider $k^{fattig}_{ss} = k^{rik}_{ss}$ i steady state som vises i likevektspunktet i h√∏yre \autoref{fig:figurx}.

Betingelsesl√∏s konvergens er den minst relevante formen for konvergens i Solow-modellens predikering av produksjon per arbeider n√•r man tar hensyn til grunnmodellen siden man kan si det ikke er realistiske forutsetninger og det sjeldent vil kunne relateres til virkeligheten.

```{python include=FALSE}
#%%capture

# Betinget konvergens figur 1
intersect1 = eq[0].subs(alpha, alpha_num).subs(s, 0.45).subs(n, 0.14)
intersect2 = eq[0].subs(alpha, alpha_num).subs(s, 0.58).subs(n, 0.12)

intersect1 = float(intersect1)
intersect2 = float(intersect2)

# Plotting the functions
fig, ax = plt.subplots(figsize=(7, 5))

ax.plot(x, neeededinv(0.12, x))
ax.plot(x, neeededinv(0.14, x), linestyle="dotted")
ax.plot(x, nettoinv(0.45, plotfunc(x, alpha_num)), linestyle="dotted")
ax.plot(x, nettoinv(0.58, plotfunc(x, alpha_num)))


# Setting k-axis label
ax.set_xlabel('k', loc='right', fontsize=15)
# Writing the equation for y = k**alpha
ax.text(52, 8.35, r'$n^{fattig} \cdot k$', fontsize=15, color='orange')
ax.text(54, 7.2, r'$n^{rik} \cdot k$', fontsize=15, color='darkslateblue')
# Writing the equation for s*y = s*k**alpha
# what is a nice red color
ax.text(55, 5.9, r'$s^{rik} \cdot k^{\alpha}$', fontsize=15, color='crimson')
# Writing the equation for s*y = s*k**alpha
ax.text(55, 4.5, r'$s^{fattig} \cdot k^{\alpha}$', fontsize=15, color='forestgreen')

#Removing spines
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')

ax.set_xticks([])
ax.set_yticks([])

# Likevekt 1
ax.text(intersect1, -0.6, r'$k_0^{fattig}$', fontsize=15)
ax.vlines(intersect1, 0, nettoinv(0.45, plotfunc(intersect1, alpha_num)), linestyle='dashed')
ax.scatter(intersect1, 0.45*plotfunc(intersect1, alpha_num), color='black', s=50)


# Likevekt 2
ax.text(intersect2, -0.5, r'$k_0^{rik}$', fontsize=15)
ax.vlines(intersect2, 0, nettoinv(0.58, plotfunc(intersect2, alpha_num)), linestyle='dashed')
ax.scatter(intersect2, 0.58*plotfunc(intersect2, alpha_num), color='black', s=50)

ax.set_xlim(0, 65)
ax.set_ylim(0, 10)
plt.savefig("ubetinget_konvergens.png", dpi=300,bbox_inches='tight')
```

```{python include= FALSE}
#%%capture

# Betinget konvergens figur 2
intersect1 = eq[0].subs(alpha, alpha_num).subs(s, 0.45).subs(n, 0.14)
intersect2 = eq[0].subs(alpha, alpha_num).subs(s, 0.58).subs(n, 0.12)
intersect3 = eq[0].subs(alpha, alpha_num).subs(s, 0.51).subs(n, 0.13)

intersect1 = float(intersect1)
intersect2 = float(intersect2)
intersect3 = float(intersect3)

# Plotting the functions
fig, ax2 = plt.subplots(figsize=(7, 5))

ax2.plot(x, neeededinv(0.12, x), label='$n^{rik} \cdot k$')
ax2.plot(x, neeededinv(0.14, x), label='$n^{fattig} \cdot k$', linestyle="dotted")
ax2.plot(x, nettoinv(0.45, plotfunc(x, alpha_num)), label=r'$s^{fattig} \cdot k^{\alpha}$',linestyle="dotted")
ax2.plot(x, nettoinv(0.58, plotfunc(x, alpha_num)), label = r'$s^{rik} \cdot k^{\alpha}$')
ax2.plot(x, neeededinv(0.13, x), label='$n \cdot k$', color="black")
ax2.plot(x, nettoinv(0.51, plotfunc(x, alpha_num)), label=r'$s \cdot k^{\alpha}$', color="black")
# Setting k-axis label
ax2.set_xlabel('k', loc='right', fontsize=15)

#Removing spines
ax2.spines['top'].set_color('none')
ax2.spines['right'].set_color('none')

ax2.set_xticks([])
ax2.set_yticks([])

# Likevekt 1
ax2.text(intersect1-1, -0.6, r'$k_0^{fattig}$', fontsize=15)
ax2.vlines(intersect1, 0, nettoinv(0.45, plotfunc(intersect1, alpha_num)), linestyle='dashed')
ax2.scatter(intersect1, 0.45*plotfunc(intersect1, alpha_num), color='black', s=50)


# Likevekt 2
ax2.text(intersect2, -0.5, r'$k_0^{rik}$', fontsize=15)
ax2.vlines(intersect2, 0, nettoinv(0.58, plotfunc(intersect2, alpha_num)), linestyle='dashed')
ax2.scatter(intersect2, 0.58*plotfunc(intersect2, alpha_num), color='black', s=50)

# Likevekt 3
ax2.text(intersect3, -0.5, r'$k_0^{ss}$', fontsize=15)
ax2.vlines(intersect3, 0, nettoinv(0.51, plotfunc(intersect3, alpha_num)), linestyle='dashed')
ax2.scatter(intersect3, 0.51*plotfunc(intersect3, alpha_num), color='black', s=50)

# showing 2 arrows
for i in range(22, 26, 3):
    ax2.arrow(i, 0, 0.5, 0, head_width=0.3, head_length=1.2, fc='black',clip_on=False)

# showing 2 arrows from the right to left
for i in range(38, 44, 3):
    ax2.arrow(i, 0, -0.5, 0, head_width=0.3, head_length=1.2, fc='black',clip_on=False)
    
# Drawing more arrows towards the steady state
ax2.arrow(57, 5.3, 0, 0.15, head_width=0.7, head_length=0.2, color='forestgreen',clip_on=False)
ax2.arrow(57, 6.3, 0, -0.15, head_width=0.7, head_length=0.2, color='crimson',clip_on=False)

ax2.arrow(55, 6.7, -0.03, 0.15, head_width=0.7, head_length=0.2, color='darkslateblue',clip_on=False)
ax2.arrow(54.5, 7.6, 0.03, -0.15, head_width=0.7, head_length=0.2, color='orange',clip_on=False)

ax2.set_xlim(0, 65)
ax2.set_ylim(0, 10)
ax2.legend(loc='upper left', fontsize=15)
plt.savefig("betinget_konvergens.png", dpi=300,bbox_inches='tight')
```

\clearpage

## **Betinget konvergens** (Ulik niv√• p√• sparerate og befolkningsvekst, √•pen √∏konomi)

To land har lik produksjon og √•pen √∏konomi, men med ulik niv√• p√• sparerate og befolkningsvekst s√• vil niv√• p√• BNP per arbeider konvergere, gitt at det er √•pne √∏konomier. Ogs√• her starter √∏konomiene i forskjellige steady states, men ender p√• sikt opp i lik steady state.

```{=tex}
\begin{wrapfigure}{r}{0.5\textwidth}
  \centering
  \includegraphics[width=0.5\textwidth]{ubetinget_konvergens.png}
  \captionof{figure}{Betinget konvergens}
  \label{fig:betinget}
  \includegraphics[width=0.5\textwidth]{betinget_konvergens.png}
  \captionof{figure}{Betinget konvergens}
  \label{fig:ubetinget}
  \vspace{-10mm}
\end{wrapfigure}
```
Det fattige landet vil i starten konvergere i likevektspunktet $k_0^{fattig}$ for n√∏dvendige og faktiske investeringer, og det samme for det rike landet i likevektspunktet for $k_0^{rik}$. Om det er lukkede √∏konomier, vil ikke landene konvergere. Men siden vi har √•pen √∏konomi s√• predikerer teorien at siden det fattige landet har lav sparerate og h√∏y befolkning og det rike landet har h√∏y sparerate men lav befolkning,s√• vil arbeidere fra det fattige landet flytte til det rike. Kapitaleire i det rike landet vil ogs√• investere i det fattige landet siden de vil f√• bedre avkastning for produksjonsfaktorene der enn hjemme.

Som man kan se i \autoref{fig:ubetinget} s√• vil dette f√∏re til at spareraten i det rike landet presses ned mens spareraten √∏ker i det fattige landet, og befolkningstallene √∏ker i det rike landet og minker i det fattige. $k_0^{rik}$ minker mens $k_0^{fattig}$ √∏ker og de to landene vil ende opp i $k_0^{ss}$ likevekt over tid. Dette er historisk sett ogs√• hva som har skjedd i virkeligheten mellom √∏konomier, men trenger ikke alltid v√¶re hva som skjer, siden man i grunnmodellen ikke har med teknologisk utvikling eller naturessurser som kan predikere at ulike √∏konomier kan ende opp i ulike steady states.

\clearpage

# Utfordring 1.3

Solow-modellen med teknologisk utvikling og naturressurser gir prediksjoner om hvordan ulike faktorer p√•virker vekstraten i BNP per innbygger p√• lang sikt.

### Presenter en ligning som beskriver vekstraten i BNP per innbygger p√• lang sikt (du trenger ikke √• utlede ligningen). Bruk ligningen til √• forklare prediksjonene til Solow-modellen i forhold til bestemmelsesfaktorer for √∏konomisk vekst p√• lang sikt.

### Gi √∏konomisk intuisjon.

```{python}

import sympy as sp

A, alpha, t, n, s, k, beta, gamma, m, h, u, A_0, R_0, L_0, g_A, j, theta, g_y = sp.symbols('A \u03B1 t n s k \u03B2 \u03B3 m h u A_0 R_0 L_0 gA j \u03B8 g_y', real=True)
Y = sp.Function('Y')(t)
K = sp.Function('K')(t)
L = sp.Function('L')(t)
qk = sp.Function('q_k')(t)
ql = sp.Function('q_l')(t)
qr = sp.Function('q_r')(t)
R = sp.Function('R')(t)
y = sp.Function('y')(t)

Yfunc = sp.Eq(Y, A * (qk * K)**alpha * (ql * L)**beta * (qr * R)**gamma)




#dividing by L
yfunc = Yfunc
yfuncright = yfunc.rhs / L
yfuncleft = yfunc.lhs / L
yfuncleft = yfuncleft.subs(Y, y*L)
yfunc = sp.Eq(yfuncleft, yfuncright)
# yfunc

#y = Y/L
yfuncright = yfuncright.subs(qk, sp.exp(j*t)).subs(ql, sp.exp(m*t)).subs(qr, sp.exp(h*t)).subs(A, A_0*sp.exp(g_A*t)).subs(L, L_0*sp.exp(n*t)).subs(R, R_0*sp.exp(-u*t))

yfunc = sp.Eq(yfuncleft, yfuncright)

#yfunc

#log of yfunc
lnyfunc = sp.Eq(sp.log(yfuncleft), sp.log(yfuncright))

#derivative of lnyfunc
dlnyfunc = sp.Eq(sp.diff(sp.log(yfuncleft), t), sp.diff(sp.log(yfuncright), t))
dlnyfunc = sp.simplify(dlnyfunc)
#dlnyfunc

dlnysubs = dlnyfunc.subs(sp.Derivative(K, t)/K, s*y/k)
dlnysubs = dlnysubs.subs(g_A+h*gamma+j*alpha+m*beta, theta)

dlnysubs = dlnysubs.subs(sp.Derivative(y, t)/y, g_y)

#dlnysubs

```

```{=tex}
\fbox{
 \addtolength{\linewidth}{-2\fboxsep}%
 \addtolength{\linewidth}{-2\fboxrule}%
\begin{minipage}{\linewidth}
\begin{equation}
    Y(t) = A(K(t)q_k(t))^\alpha(L(t)q_l(t))^\beta (R(t)q_r(t))^\gamma 
\end{equation}
\begin{equation}
    y(t) = \frac{A_0 K(t) e^{jt})^\alpha (L_0 e^{mt} e^{n t})^{\beta} (R_0 e^{ht} e^{-ut})^\gamma e^{g_At} e^{-n t}}{L_0}
\end{equation}
\begin{equation}
    \frac{\frac{d}{dt} y(t)}{y(t)} = g_A + \gamma h + \alpha j + \beta m + \beta n - n - u \gamma + \alpha \frac{\frac{d}{dt} K(t)}{K(t)}
\end{equation}
\begin{equation*}
    \frac{\partial K}{t} = s\cdot Y => \frac{\frac{\partial K}{\partial t}}{K(t)} = \frac{sY}{K} = \left(\frac{sy}{k}\right)
\end{equation*}
\begin{equation*}
    \frac{\frac{d}{dt} y(t)}{y(t)} = g_y
\end{equation*}
\begin{equation}
    g_y = g_A + \gamma h + \alpha j + \beta m + \beta n - n - u \gamma + \alpha \left(\frac{sy}{k}\right)
\end{equation}
\begin{equation*}
    \theta = g\_A + \gamma h + \alpha j + \beta m 
\end{equation*}
\begin{equation}
    g_y = \theta + \beta n - n - u \gamma + \alpha \left(\frac{sy}{k}\right)
\end{equation}
\begin{equation*}
    \beta+\alpha+\gamma = 1 => \beta = \alpha - \gamma +1
\end{equation*}
\begin{equation}
    g_y = \theta + n(-\alpha-\beta+1) - n - u \gamma + \alpha \left(\frac{sy}{k}\right)
\end{equation}
\begin{equation}
    g_y = \theta - \alpha n - n \gamma - u \gamma + \alpha \left(\frac{sy}{k}\right)
\end{equation}
 \end{minipage}
}

\begin{equation}
    g_y = \theta + \alpha \left(\frac{sy-nk}{k}\right) - \gamma (u+n)
\end{equation}


```
$\left(\frac{sy-nk}{k}\right)$ viser oss vekstraten i kapital. Sparerate multiplisert med produksjon per arbeider, dette substraheres med befolkningsvekstraten multiplisert med kapital. Dette deles avsluttningsvis p√• kapital for √• endelig gi oss vekstraten i kapital.

$\gamma (u+n)$ viser oss hvor mye naturressursene brukes opp i forhold til befolkningsvekstraten, u definerer vi som reduksjonen i naturressursene og n definerer vi som befolkningsveksten (fikser dere bokstavene u og n i s√•nn form)

Ligningen ùëîùë¶(ùë°) =0 ùõº ((ùë†ùë¶(ùë°) ‚àí ùëõùëò)/ùëò(ùë°)) ‚àí ùõæ(ùë¢ + ùëõ) (kan dokker legge inn den ligninga som der oppe her og samme i de delene her under) viser produksjonen pr arbeider. Man tar utgangspunkt n√• at teknologi er konstant.

Hvis 0 ùõº (ùë†ùë¶(ùë°)‚àíùëõùëò/ùëò(ùë°)) er mindre enn ‚àíùõæ(ùë¢ + ùëõ) s√• vil man f√• redusert eller negativ √∏konomisk vekst, da man bruker opp naturressursene, eller ved befolkningsvekst som er h√∏y s√• vil det v√¶re flere √• dele kapitalen p√• som igjen gj√∏r at arbeidseffektiviteten blir mindre, og det er gitt at det ikke er mulig √• investere nok for √• oppretholde stady state.

Men hvis 0 ùõº (ùë†ùë¶(ùë°)‚àíùëõùëò/ùëò(ùë°)) er st√∏rre enn ‚àíùõæ(ùë¢ + ùëõ), s√• vil det gi en positiv √∏konomisk vekst, hvis befolkningsveksten er lavere enn det man kan investere som gj√∏r at det blir litt h√∏yere kapital pr arbeider, eller at naturressursene ikke brukes for mye av i produksjonen, eller at hvis sparingen og investeringen er h√∏y s√• vil dette √∏ke produksjonen og dermed bidra til √∏konomisk vekst.

\clearpage

```{python include= FALSE}

#Fors√∏ker √• pr√∏ve √• finne likevekt, f√∏lger video som Andrea har laget men fikk ikke helt til. henter s√• funksjon fra seminar

A, alpha, t, n, s, k, beta, gamma, m, h, u, A_0, R_0, L_0, g_A, j, theta, g_y = sp.symbols('A \u03B1 t n s k \u03B2 \u03B3 m h u A_0 R_0 L_0 gA j \u03B8 g_y', real=True)
Y = sp.Function('Y')(t)
K = sp.Function('K')(t)
L = sp.Function('L')(t)
qk = sp.Function('q_k')(t)
ql = sp.Function('q_l')(t)
qr = sp.Function('q_r')(t)
R = sp.Function('R')(t)
y = sp.Function('y')(t)

Yfunc = sp.Eq(Y, A * (qk * K)**alpha * (ql * L)**beta * (qr * R)**gamma)


Yfunc_delt_pa_yalpha = sp.Eq(Yfunc.lhs/Y**(alpha), Yfunc.rhs/Y**(alpha))
Yfunc_delt_pa_yalpha = sp.simplify(Yfunc_delt_pa_yalpha)


Yfunc_delt_pa_1over = sp.Eq(Yfunc_delt_pa_yalpha.lhs**(1/(1-alpha)), Yfunc_delt_pa_yalpha.rhs**(1/(1-alpha)))
Yfunc_delt_pa_L = sp.Eq(Yfunc_delt_pa_1over.lhs/L, Yfunc_delt_pa_1over.rhs/L)
Yfunc_log = sp.Eq(sp.log(Yfunc_delt_pa_L.lhs), sp.log(Yfunc_delt_pa_L.rhs))





#ender med √• hente kode fra Andrea


t = np.linspace(0, 100, 500)
y0 = 600
alpha = 0.2
beta = 0.6
gamma = 0.2

n = 0.02
u = 0.0001


ga0 = 0
j0 = 0
m0 = 0
h0 = 0

ga1, j1, m1, h1 = 0.01, 0.01, 0.01, 0.01

alpha3, beta3, gamma3 = 0.3, 0.3, 0.4


def yt_1(t):
    return y0 * np.exp((((1/(1-alpha))*(ga0+alpha*j0+beta*m0 +gamma*h0))-(gamma/(1-alpha))*(u+n)) * t)

def yt_2(t):
    return y0 * np.exp((((1/(1-alpha3))*(ga0+alpha3*j0+beta3*m0 +gamma3*h0))-(gamma3/(1-alpha3))*(u+n)) * t)




def yt_3(t):
    return y0 * np.exp((((1/(1-alpha))*(ga1+alpha*j1+beta*m1 +gamma*h1))-(gamma/(1-alpha))*(u+n)) * t)

def yt_4(t):
    return y0 * np.exp((((1/(1-alpha3))*(ga1+alpha3*j1+beta3*m1 +gamma3*h1))-(gamma3/(1-alpha3))*(u+n)) * t)




fig, ax = plt.subplots()


#ax.axhline(y=600, color='red', linestyle='--', label='Likevekt ved n=u=0')

ax.plot(t, yt_1(t), label='Ingen teknologisk utvikling, men n og u>0', color="gray")
ax.plot(t, yt_2(t), label='alpha og beta synker mens gamma √∏ker', color='gray')


ax.plot(t, yt_3(t), label='Med teknologisk utvikling men n og u>0', color='black')
ax.plot(t, yt_4(t), label='alpha og beta synker mens gamma √∏ker', color='black')




#ax.text(95, 600, '$y_0$', verticalalignment='bottom', horizontalalignment='right')


ax.text(95, yt_1(95), '$g_{y1}$', verticalalignment='bottom', horizontalalignment='right')
ax.text(95, yt_2(95), '$g_{y2}$', verticalalignment='bottom', horizontalalignment='right')
ax.text(95, yt_3(95), '$g_{y3}$', verticalalignment='bottom', horizontalalignment='right')
ax.text(95, yt_4(95), '$g_{y4}$', verticalalignment='bottom', horizontalalignment='right')



ax.set(xlabel='√Ör', ylabel='BNP per kapita')
ax.grid(True)
ax.legend()


plt.savefig('utf13_steadystate.png', dpi=300, bbox_inches='tight')




```

```{=tex}
\begin{wrapfigure}{r}{0.5\textwidth}
    \includegraphics[width=0.48\textwidth]{utf13_steadystate.png}
  \caption{Likevekt i Solow-modellen med teknologi og naturressurser}
  \label{fig:likevekt_grunnleggende}
  \vspace{-12mm}
\end{wrapfigure}
```
\clearpage

# Referanser

::: {#refs}
:::

\clearpage

\appendix

\section {Appendix Generell KI bruk}

I l√∏pet av koden s√• kan det ses mange \# kommentarer der det er skrevet for eks "#fillbetween q1 and q2". N√•r jeg skriver kode i Visual Studio Code s√• har jeg en plugin som heter Github Copilot. N√•r jeg skriver slike kommentarer s√• kan den fores√∏ke √• fullf√∏re kodelinjene mens jeg skriver de. Noen ganger klarer den det, men andre ikke. Det er vanskelig √• dokumentere hvert bruk der den er brukt siden det "g√•r veldig fort" men siden jeg ikke har f√•tt p√• plass en slik dokumentasjon s√• kan all python kode der det er brukt kommentarer antas som at det er brukt Github Copilot. N√¶rmere info om dette KI verkt√∏yet kan ses p√• <https://github.com/features/copilot>

\section {Appendix 1.1 KI bruk}

\section {Appendix Kapittel 1.2 KI bruk}

\subsection{her har daniel med liten d brukt masse chatgpt} \label{appendix:appendixkart}

\section {Appendix Kapittel 1.3 KI bruk}
